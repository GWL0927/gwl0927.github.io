<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>浏览器和网络协议 | GWL's Blog</title><meta name="keywords" content="浏览器和网络协议"><meta name="author" content="郭威龙"><meta name="copyright" content="郭威龙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="axioscreateInstance底层根据默认设置 新建一个Axios对象， axios中所有的请求[axios, axios.get,axios.post等…]内部调用的都是Axios.prototype.request,将Axios.prototype.request的内部this绑定到新建的Axios对象上,从而形成一个axios实例。新建一个Axios对象时，会有两个拦截器，reque">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器和网络协议">
<meta property="og:url" content="http://example.com/2021/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="GWL&#39;s Blog">
<meta property="og:description" content="axioscreateInstance底层根据默认设置 新建一个Axios对象， axios中所有的请求[axios, axios.get,axios.post等…]内部调用的都是Axios.prototype.request,将Axios.prototype.request的内部this绑定到新建的Axios对象上,从而形成一个axios实例。新建一个Axios对象时，会有两个拦截器，reque">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/27/5T4zgf.png">
<meta property="article:published_time" content="2021-10-07T01:48:05.000Z">
<meta property="article:modified_time" content="2021-10-27T02:29:05.381Z">
<meta property="article:author" content="郭威龙">
<meta property="article:tag" content="浏览器和网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/10/27/5T4zgf.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浏览器和网络协议',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-27 10:29:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/TimCook.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://z3.ax1x.com/2021/10/27/5T4zgf.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GWL's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">浏览器和网络协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-07T01:48:05.000Z" title="发表于 2021-10-07 09:48:05">2021-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-27T02:29:05.381Z" title="更新于 2021-10-27 10:29:05">2021-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="浏览器和网络协议"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>createInstance底层根据默认设置 新建一个Axios对象， axios中所有的请求[axios, axios.get,axios.post等…]内部调用的都是Axios.prototype.request,将Axios.prototype.request的内部this绑定到新建的Axios对象上,从而形成一个axios实例。新建一个Axios对象时，会有两个拦截器，request拦截器，response拦截器。</p>
<p>1、请求拦截器<br> 请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么，例如加入token</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>2、响应拦截器<br> 响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在接收响应做些什么，例如跳转到登录页</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API</li>
<li>它可以拦截请求和响应</li>
<li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据</li>
<li>安全性更高，客户端支持防御 XSRF</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>axios.get(url[, config])   //get请求用于列表和信息查询</li>
<li>axios.delete(url[, config])  //删除</li>
<li>axios.post(url[, data[, config]])  //post请求用于信息的添加</li>
<li>axios.put(url[, data[, config]])  //更新操作</li>
</ol>
<h2 id="axios相关配置属性"><a href="#axios相关配置属性" class="headerlink" title="axios相关配置属性"></a>axios相关配置属性</h2><ol>
<li> <code>url</code>是用于请求的服务器URL</li>
<li><code>method</code>是创建请求时使用的方法,默认是get</li>
<li><code>baseURL</code>将自动加在<code>url</code>前面，除非<code>url</code>是一个绝对URL。它可以通过设置一个<code>baseURL</code>便于为axios实例的方法传递相对URL</li>
<li><code>transformRequest</code>允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法</li>
<li><code>headers</code>是即将被发送的自定义请求头<br> headers:{‘X-Requested-With’:’XMLHttpRequest’},</li>
<li><code>params</code>是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象<br> params:{<br> ID:12345<br> },</li>
<li><code>auth</code>表示应该使用HTTP基础验证，并提供凭据<br> 这将设置一个<code>Authorization</code>头，覆写掉现有的任意使用<code>headers</code>设置的自定义<code>Authorization</code>头<br> auth:{<br> username:’janedoe’,<br> password:’s00pers3cret’<br> },</li>
</ol>
<h1 id="输入URL后发生了什么"><a href="#输入URL后发生了什么" class="headerlink" title="输入URL后发生了什么"></a>输入URL后发生了什么</h1><ol>
<li>浏览器地址输入URL并按下回车</li>
<li>浏览器查找当前URL的DNS缓存记录</li>
<li>DNS解析当前URL对应的IP</li>
<li>根据IP建立TCP连接（三次握手）</li>
<li>发起HTTP请求</li>
<li>服务器处理请求，浏览器接受HTTP响应</li>
<li>渲染页面，构建DOM树</li>
<li>关闭TCP连接（四次挥手）</li>
</ol>
<h1 id="浏览器接收HTTP响应"><a href="#浏览器接收HTTP响应" class="headerlink" title="浏览器接收HTTP响应"></a>浏览器接收HTTP响应</h1><p>服务器在收到浏览器发送的HTTP请求后，会将收到的HTTP报文封装成HTTP的Request对象，并且会通过不同的Web服务器进行处理，处理完的结果以HTTP的Requeset对象返回，主要包括状态码，响应头，响应报文三个部分。</p>
<h1 id="网页生成过程"><a href="#网页生成过程" class="headerlink" title="网页生成过程"></a>网页生成过程</h1><ol>
<li>HTML被HTML解析器解析成DOM树</li>
<li>CSS被CSS解析器解析成CSSOM树</li>
<li>结合DOM树和CSSOM树，生成一颗渲染树Render Tree</li>
<li>生成布局flow，就是将所有渲染树的所有结点进行平面合成</li>
<li>将布局绘制paint在屏幕上</li>
</ol>
<h1 id="浏览器回流"><a href="#浏览器回流" class="headerlink" title="浏览器回流"></a>浏览器回流</h1><p><strong>重绘：</strong>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p>
<p><strong>回流：</strong>当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p>
<h2 id="哪些因素会导致回流？"><a href="#哪些因素会导致回流？" class="headerlink" title="哪些因素会导致回流？"></a>哪些因素会导致回流？</h2><p>1、调整窗口的大小；</p>
<p>2、改变字体，如果用rem 设置了根目录的字体大小，这样就减少了回流的次数；</p>
<p>3、增加或者移除样式表；</p>
<p>4、内容的变化，用户在input中输入了文字（这是不可避免的）；</p>
<p>5、激活CSS的伪类；</p>
<p>6、操作class属性；</p>
<p>7、基本操作DOM(包括js中的domcument等)；</p>
<p>8、计算offsetWidth与offsetHeight 属性，获取元素在窗口中的位置；</p>
<p>9、在html代码中直接设置style 属性的值，这个降低了代码的利用率，还影响性能。</p>
<h2 id="如何避免回流？"><a href="#如何避免回流？" class="headerlink" title="如何避免回流？"></a>如何避免回流？</h2><p>1、如果想设定元素的样式，直接改变class名，而不是改变class中的某个特定的属性，比如height，weight;</p>
<p>2、避免设置多项内联样式，就是说少使用style；</p>
<p>3、应用元素动画的时候，使用属性的position属性的fixed值或absolute值；</p>
<p>4、避免使用table布局；</p>
<p>5、尽量在DOM树的最末端改变class,改变子节点的样式。</p>
<h1 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h1><h2 id="无名管道（普通管道）"><a href="#无名管道（普通管道）" class="headerlink" title="无名管道（普通管道）"></a>无名管道（普通管道）</h2><p>普通管道允许两个进程按标准的生产者-消费者方式进行通信：生产者向管道的一端（写入端）写，消费者从管道的另一端（读出端）读。</p>
<p>因此，普通管道是单向的，只允许单向通信。如果需要双向通信，那么就要采用两个管道，而每个管道向不同方向发送数据。</p>
<h2 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h2><p><strong>有名管道</strong>提供了一个更强大的通信工具。通信可以是双向的，并且父子关系不是必需的，当建立了一个有名管道后，多个进程都可用它通信。</p>
<h1 id="OSI七层模型和TCP-IP五层模型"><a href="#OSI七层模型和TCP-IP五层模型" class="headerlink" title="OSI七层模型和TCP/IP五层模型"></a>OSI七层模型和TCP/IP五层模型</h1><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oi8C6"><img src="https://z3.ax1x.com/2021/10/26/5oi8C6.md.png" alt="5oi8C6.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oiCHs"><img src="https://z3.ax1x.com/2021/10/26/5oiCHs.md.png" alt="5oiCHs.md.png"></a></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>HTTP协议是基于TCP/IP协议之上的应用层协议，主要用于规定互联网联网中<strong>客户端和服务器之间的通信格式</strong>，不关系具体的传输细节，默认80端口</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求行、请求头、空行、请求数据4个部分组成</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求方法、请求地址和协议版本</p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>请求方法是客户端用来告知服务端其操作意图的一个命令。几种方法的说明： </p>
<ul>
<li>GET： 用于获取资源。</li>
<li>POST： 用于传输实体主体。</li>
<li>PUT：用于传输文件。PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。</li>
<li>HEAD：获取报文首部。HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。用于确认URL的有效性及资源更新时间等。 </li>
<li>DELETE：用于删除文件。DELETE方法用来删除文件，是与PUT相反的方法。DELETE是要求返回URL指定的资源。 </li>
<li>OPTIONS： 用于询问服务器支持的请求方法。OPTIONS 方法用来查询针对请求 URL 指定的资源支持的方法。有些服务器为了安全考虑会将PUT、DELETE方法禁用，这时可以先用OPTIONS查询支持的方法。</li>
<li>TRACE：追踪路径。TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。这个方法并不常用。 </li>
<li>CONNECT：要求用隧道协议连接代理。CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL/TLS协议对通信内容加密后传输。</li>
</ul>
<h4 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h4><p>URL：同意资源定位符，组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p>
<h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><p>HTTP/1.1、HTTP/2 </p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzM5ODU1NjMtNTM5Mzc4ZWVlMTRmYTMyMi5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p><strong>请求头部的最后会有一个空行，表示请求头部结束</strong>，接下来为请求数据，这一行非常重要，必不可少。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>可选部分，比如GET请求就没有请求数据</p>
<p>下面是一个POST方法的请求报文：</p>
<blockquote>
<p>POST 　/index.php　HTTP/1.1 　　 请求行<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-cn,zh;q=0.5<br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive<br>Referer: <a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a><br>Content-Length：25<br>Content-Type：application/x-www-form-urlencoded<br>　　空行<br>username=aa&amp;password=1234　　请求数据</p>
</blockquote>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>状态行、响应头部、空行、响应数据</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>协议版本、状态码、状态码描述</p>
<h4 id="协议版本-1"><a href="#协议版本-1" class="headerlink" title="协议版本"></a>协议版本</h4><p>其中协议版本与请求报文一致</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx：指示信息-表示请求已接收，继续处理</p>
<p>2xx：成功-表示请求已被成功接收、理解、接受</p>
<ul>
<li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li>
<li>201 （已创建） 请求成功并且服务器创建了新的资源。                              </li>
<li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li>
</ul>
<p>3xx：重定向-要完成请求必须进行更进一步的操作</p>
<ul>
<li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li>
<li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li>
</ul>
<p>4xx：客户端错误-请求有语法错误或者请求无法实现</p>
<ul>
<li>400 （错误请求） 服务器不理解请求的语法。</li>
<li>403 （禁止） 服务器拒绝请求。</li>
<li>404 （未找到） 服务器找不到请求的网页。</li>
</ul>
<p>5xx：服务器端错误-服务器未能实现合法的请求</p>
<ul>
<li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li>
<li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>与请求头类似，为响应报文添加了一些附加信息</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzM5ODU1NjMtMzNlZDk1NDc5ZjU0MWEwNy5wbmc?x-oss-process=image/format.png" alt="img"></p>
<h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>用于存放需要返回给客户端的数据信息。</p>
<p>下面是一个响应报文的实例：</p>
<blockquote>
<p>HTTP/1.1 200 OK　　状态行<br>Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部<br>Server: Apache/2.2.8 (Win32) PHP/5.2.5<br>X-Powered-By: PHP/5.2.5<br>Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/<br>Expires: Thu, 19 Nov 1981 08:52:00 GMT<br>Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br>Pragma: no-cache<br>Content-Length: 4393<br>Keep-Alive: timeout=5, max=100<br>Connection: Keep-Alive<br>Content-Type: text/html; charset=utf-8<br>　　空行</p>
<html>　　响应数据

<body>
Hello HTTP!
</body>
</html>
</blockquote>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>增加PUT\PATCH\DELETE等命令，并新增了一些功能机制: </p>
<ul>
<li><strong>持久连接</strong>(keep-alive可保持长连接，减少重复请求)。 </li>
<li>管道机制(pipelining，一个TCP连接中客户端可同时发送多个请求)。Content-Length字段（报文内容长度）。 </li>
<li>Host字段(用于指定服务器域名，可以将请求发往同一台服务器的不同站点)。1.1版本基本完善了HTTP协议，并且一直使用至今仍然是目前最流行的版本。</li>
</ul>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>主要有以下特点： </p>
<ul>
<li>二进制协议(HTTP/1.1版本头信息使用文本格式，数据体可以是文本或二进制格式，而HTTP/2版本则全部使用二进制格式,方便将来扩展)。</li>
<li>多工传输(复用TCP连接，双向实时通信，客户端服务器可同时发送多个请求和响应，并且不需要按照请求顺序回应，避免队头阻塞问题)。 </li>
<li>头信息压缩(HTTP协议是无状态的，因此很多请求都需要带上Cookie、User Agent等重复字段，影响效率。HTTP/2使用gzip、compress等算法压缩头信息后，并且在客户端和服务器都维护一张头信息表，记录这些字段，从而提高速度)。</li>
</ul>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>由于HTTP通信是全明文传输的，很多敏感信息容易被窃取。网景公司(Netspace)，发明了SSL协议，用于对HTTP传输的内容进行安全加密。后来互联网标准化组织IETF将SSL推广并重新命名为TLS协议，所以SSL和TLS基本是一个东西。</p>
<h2 id="协议特点"><a href="#协议特点" class="headerlink" title="协议特点"></a>协议特点</h2><ul>
<li>基于TCP协议：HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。 </li>
<li>无状态连接：HTTP协议本身不对请求和响应之间的通信状态进行保存。 </li>
<li>多次请求：由于管道机制可实现一次TCP连接同时多个HTTP请求。客户端请求服务器时先响应HTML，再请求加载CSS,JS，图片等资源。 </li>
<li>持久连接：当TCP连接建立后，只要任意一端没有明确提出断开连接，则保持TCP连接状态。减少TCP重复建立和断开的开销及服务器端的负载。 </li>
<li>使用Cookie和Session机制管理状态：为了实现保存通信状态，引入了Cookie和Session技术。比如用户登录网站跳转到其他页面能够保存用户状态，而不需要重新登录。 </li>
<li>全明文传输: 报文数据不加密（这一方面从某种意义上也方便了开发人员调试bug），敏感信息易泄露。可通过在代码上使用SSL/TLS协议改造系统，加密请求响应报文，需调试可将报文解密后保存到日志中进行问题排查。</li>
<li>内容编码: 由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。 </li>
<li>范围请求: 当客户端请求的数据内容过大时，比如请求一张很大的图片，会发现有时候图片是一块一块加载的。<strong>这就是因为设置了http请求的长度，这样就可以分块的加载资源文件。</strong>在请求报文中使用Range属性，在响应报文中使用Content-Type属性都可以指定一定字节范围的http请求。 </li>
<li>多部分对象集合: 报文传输的内容，不仅仅是一些字符串，还有可能是一些图片，字符，音乐二进制等混杂的内容。这就需要使用多部分对象集合，multipart。默认的情况下form使用的编码格式是：applicatin/x-www-form-urlencoded，这种编码格式会把所有的内容进行编码，不适合上传文件这种情况。multipart/form-data 会以控件为基准，编码form中的内容。application/x-www-form-urlencoded 会把form中的内容编码成键值对的形式。</li>
</ul>
<h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><p>HTTPS = HTTP + SSL/TLS，可进行加密传输、身份认证，默认443端口，需要使用CA证书，免费证书较少，需交费。</p>
<p>HTTPS有以下几个特点: </p>
<ul>
<li>所有信息都是加密传播，黑客无法窃听。</li>
<li>具有校验机制，一旦被篡改，通信双方会立刻发现。 </li>
<li>配备身份证书，防止身份被冒充。</li>
</ul>
<p>HTTPS 的实现原理:</p>
<p><strong>非对称加密</strong>只作用在证书验证阶段。</p>
<ol>
<li>浏览器发起 HTTPS 请求；</li>
<li>服务端返回 HTTPS 证书；</li>
<li>客户端验证证书是否合法，如果不合法则提示告警。</li>
</ol>
<p><strong>对称加密</strong>作用在数据传输阶段</p>
<ol>
<li>当证书验证合法后，在本地生成随机数；</li>
<li>通过公钥加密随机数，并把加密后的随机数传输到服务端；</li>
<li>服务端通过私钥对随机数进行解密；</li>
<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。</li>
</ol>
<h1 id="HTTPS的交互流程"><a href="#HTTPS的交互流程" class="headerlink" title="HTTPS的交互流程"></a>HTTPS的交互流程</h1><p><img src="https://img.136.la/20210425/b9852e8202f049c4bc2e16a11bd6390c.jpg" alt="ãç½ç»éä¿¡ãHTTPSä¸ºä»ä¹è¦ç¨å°å¯¹ç§°å å¯åéå¯¹ç§°å å¯ï¼ç¸å¯¹äºåªä½¿ç¨éå¯¹ç§°å å¯æä»ä¹å¥½å¤ï¼"></p>
<p>1、客户端发起https请求，连接到服务器的443端口</p>
<p>2、服务端返回证书</p>
<p>3、客户端验证证书的合法性</p>
<p>4、客户端生成随机密码</p>
<p>如果验证通过，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务器用私钥解密，解密后就用这个对称密钥进行传输了，说明服务端是私钥的持有者。</p>
<p>5、生成对称加密算法</p>
<p>验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，<strong>以公钥加密之后发给服务端</strong>。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端和服务端就可以用这个对称加密算法来加密和解密通信内容了。</p>
<h2 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h2><p>首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。</p>
<p>另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</p>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>SYN：synchronous 建立联机</p>
<p>ACK：acknowledgement 确认</p>
<p>FIN：finish 结束</p>
<p>Seq：Sequence number 顺序号码</p>
<p>第一次：<strong>客户端</strong>给服务端发送一个SYN报文，报文中指明客户端的初始化序列号seq = J，此时客户端处于<strong>SYN_Send</strong>状态</p>
<p>第二次：<strong>服务端</strong>收到客户端的SYN报文后，以自己的SYN报文作为应答，报文中也指明了自己的初始化序列号seq = K，并且以客户端的J + 1作为ACK的值，表示收到了客户端的SYN，此时服务端处于<strong>SYN_REVD</strong>状态</p>
<p>第三次：<strong>客户端</strong>收到服务端的SYN报文后，也以服务端的K + 1作为ACK的值，表示收到了服务端的SYN报文，此时客户端处于<strong>established</strong>状态</p>
<p>服务端收到客户端的ACK报文后，也处于<strong>established</strong>状态，此时双方建立起了连接</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf9bd409c5624da0970f8227784ac728~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>刚开始双方都处于established状态，假如是客户端先发起关闭请求，则：</p>
<p>第一次：<strong>客户端</strong>发送一个FIN报文，报文中指明客户端的初始化序列号M，<strong>FIN_WAIT1</strong>状态</p>
<p>第二次：<strong>服务端</strong>收到客户端的FIN之后，以客户端的序列号M + 1作为ACK报文发送，表示已经收到客户端的报文，<strong>CLOSE_WAIT</strong>状态</p>
<p>第三次：如果<strong>服务端</strong>也想断开连接了，给客户端发送一个FIN报文，报文中指明一个序列号N，此时服务端处于<strong>LAST_ACK</strong>状态</p>
<p>第四次：<strong>客户端</strong>收到FIN之后，以服务端的序列号N + 1作为ACK报文向服务端应答，此时客户端处于<strong>TIME_WAIT</strong>状态。需要等到确保服务端收到自己的ACK报文之后才进入<strong>CLOSED</strong>状态</p>
<p>服务端收到ACK报文后，就处于<strong>CLOSED</strong>状态了</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/285729db06404505887b554c12d4c230~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h1 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h1><ol>
<li>HTTP是不安全的，HTTPS是安全的</li>
<li>HTTP标准端口是80，HTTPS标准端口是443</li>
<li>HTTP无法加密，HTTPS对传输的数据进行加密</li>
<li>HTTP无需证书，HTTPS需要CA机构颁发的SSL证书</li>
<li>在OSI网络模型中，HTTP工作于应用层，HTTPS的安全传输机制工作在传输层</li>
</ol>
<h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><table>
<thead>
<tr>
<th>区别</th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h1 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h1><p>GET和POST是什么？<br>HTTP中两种发送请求的方法。</p>
<p>HTTP是什么？<br>HTTP是基于TCP/IP的关于数据如何在万维网中传递的通信协议。</p>
<p>HTTP的底层是TCP/IP，所以GET和POST底层也是TCP/IP，也就是说<strong>GET和POST都是TCP链接</strong>。GET和POST能做的事情是一样的。你要给GET加上request body或者给POST带上url参数技术上是完全行的通的。</p>
<ol>
<li>GET在浏览器回退后不会再次请求，POST会再次提交请求</li>
<li>GET请求会被浏览器主动缓存，POST不会，需要手动设置</li>
<li>GET参数会被完整保留在浏览器历史记录里，POST不会</li>
<li>GET请求URL中传递的参数是有长度限制的，POST没有限制</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>GET一般用于查询信息，POST一般用于提交某种信息进行修改操作</li>
<li>GET产生一个TCP数据包，POST产生两个TCP数据包（是否再发送一个包取决了客户端的实现策略）</li>
</ol>
<p><strong>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p>
<p>为什么<strong>GET产生一个TCP数据包，POST产生两个TCP数据包</strong>？</p>
<ul>
<li>对于GET请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li>
<li>对于POST请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。要<strong>跟踪该会话</strong>，必须引入一种机制。Cookie就是这样的一种机制。</p>
<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？</p>
<p><strong>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理</strong>。</p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。<strong>客户端浏览器会把Cookie保存起来。</strong>当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p>cookie路径path：<br>cookie 一般是由与用户访问页面而被创建的 ， 可是并不是只有在创建 cookie 的页面才可以访问这个cookie。在默认情况下，出于安全方面的考虑，<br>只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。<br>那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。<br>cookie域名domain：<br>domain表示的是cookie所在的域，默认为请求的地址，如网址为<a target="_blank" rel="noopener" href="http://www.jb51.net/test/test.aspx%EF%BC%8C%E9%82%A3%E4%B9%88domain%E9%BB%98%E8%AE%A4%E4%B8%BAwww.jb51.net%E3%80%82">www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。</a><br>而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个让域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个让域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是服务器端使用的一种记录客户端状态的机制。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>Session的生命周期：</p>
<ol>
<li>Session在用户第一次访问服务器的时候自动创建。</li>
<li>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。</li>
</ol>
<p>Session的有效期：</p>
<p>为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。</p>
<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><p>Cookie机制是通过检查客户身上的<strong>Cookie信息</strong>来确定客户身份，Session机制就是通过检查服务器上的<strong>Session中该客户的状态</strong>来确认客户身份。</p>
<ul>
<li>Cookie保存在客户端浏览器中，而Session保存在服务器上</li>
</ul>
<p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。<strong>而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。</strong></p>
<ul>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</li>
<li><strong>两者最大的区别在于生存周期，一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</strong></li>
</ul>
<h1 id="Web-Storage和Cookie的区别"><a href="#Web-Storage和Cookie的区别" class="headerlink" title="Web Storage和Cookie的区别"></a>Web Storage和Cookie的区别</h1><p>Web Storage的概念和cookie相似，<strong>区别是它是为了更大容量存储设计的</strong>。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外<strong>cookie还需要指定作用域，不可以跨域调用</strong>。除此之外，Web Storage拥有<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等方法，不像cookie需要前端开发者自己封装<code>setCookie</code>,<code>getCookie</code>。</p>
<p>但是Cookie也是不可以或缺的：<strong>Cookie的作用是与服务器进行交互</strong>，作为HTTP规范的一部分而存在 ，<strong>而Web Storage仅仅是为了在本地“存储”数据而生</strong>。</p>
<p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage<br><strong>sessionStorage</strong>用于本地存储一个会话（ session ）中的数据（非持久化的本地存储），这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁；<br><strong>localStorage</strong>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上</p>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>浏览器缓存机制也就是HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的</p>
<p>HTTP报文分为两种</p>
<ul>
<li><strong>HTTP请求(Request)报文</strong>，报文格式为：<strong>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</strong></li>
<li><strong>HTTP响应(Response)报文</strong>，报文格式为：<strong>状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</strong></li>
</ul>
<p>缓存过程</p>
<p>浏览器与服务器通信的方式为应答模式，即是：<strong>浏览器发起HTTP请求 – 服务器响应该请求</strong>。浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/1/30SJ6B9RIagMBY6Bc7S2vkKSu3.png" alt="img"></p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p><strong>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>，强制缓存的情况主要有三种，如下：</p>
<p>（1）不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/1/30ThRw5TMP5GXcIzFUhJCiYVG-.png" alt="img"></p>
<p>（2）存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/1/30Bd_Ct_JmCV4IGWgVwrwonHCh.png" alt="img"></p>
<p>（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/1/30WBGAfz4BMLy-ZaljsVGF0Z9z.png" alt="img"></p>
<h3 id="强制缓存的缓存规则"><a href="#强制缓存的缓存规则" class="headerlink" title="强制缓存的缓存规则"></a>强制缓存的缓存规则</h3><p>当浏览器向服务器发送请求的时候，服务器会将<strong>缓存规则</strong>放入HTTP响应的报文的HTTP头中和请求结果一起返回给浏览器，<strong>控制强制缓存的字段分别是Expires和Cache-Control</strong>，其中Cache-Conctrol的优先级比Expires高。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间，即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<p><strong>Expires控制缓存的原理</strong>是使用<strong>客户端的时间</strong>与<strong>服务端返回的时间</strong>做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<p>（1）<strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存）</p>
<p>（2）<strong>private</strong>：所有内容只有客户端可以缓存，<strong>Cache-Control的默认取值</strong></p>
<p>（3）<strong>no-cache</strong>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p>
<p>（4）<strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>
<p>（5）**max-age=xxx (xxx is numeric)**：缓存内容将在xxx秒后失效</p>
<p><strong>在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</strong></p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>跨域是因为浏览器的<strong>同源策略</strong>机制存在而产生的</p>
<p>同源策略：浏览器出于安全考虑，只允许与本域下的接口进行交互，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p>
<p>同源（本域）的概念：</p>
<ul>
<li>同协议：都是为http或者https；</li>
<li>同域名：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://a.com/index.html">http://a.com/index.html</a> 与 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://a.com/server.js">http://a.com/server.js</a> 域名一致；</li>
<li>同端口：端口号一致（如都为8080）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.abc.com/index.html">http://www.abc.com/index.html</a>  调用  <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.def.com/server.php">http://www.def.com/server.php</a><br> （主域名不同，跨域）</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://abc.a.com/index.html">http://abc.a.com/index.html</a>   调用  <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://def.a.com/server.php">http://def.a.com/server.php</a><br> （子域名不同:abc/def，跨域）</p>
<p> （端口不同，跨域）<br> （协议不同:http/https，跨域）</p>
<h2 id="跨域的实现"><a href="#跨域的实现" class="headerlink" title="跨域的实现"></a>跨域的实现</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP(JSON with padding)原理：</p>
<p> 利用html里面script标签并不被同源策略所约束，可以加载其他域下的js这一特性，使用script src的形式来获取其他域下的数据，但是因为是通过标签引入的，所以会将请求到的JSON格式的数据作为js去运行处理，显然这样运行是不行的，所以就需要提前将返回的数据包装一下，封装成函数进行运行处理，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。（JSONP 需要对应接口的后端的配合才能实现）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">ret</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ret);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://api.jirengu.com/weather.php?callback=showData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>限制：</p>
<ul>
<li>需要服务的支持</li>
<li>只能发起GET请求</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享（Cross-Origin Resource Sharing），是一种 ajax 跨域请求资源的方式，支持现代浏览器，IE支持10以上。</p>
<p>实现方式：</p>
<ol>
<li>当使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin;</li>
<li>后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; </li>
<li>浏览器判断该响应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据。</li>
</ol>
<p>优势：</p>
<ul>
<li>在服务端进行控制是否允许跨域，可自定义规则</li>
<li>支持各种请求方式</li>
</ul>
<p>缺点：</p>
<ul>
<li>会产生额外的请求</li>
</ul>
<h3 id="降域"><a href="#降域" class="headerlink" title="降域"></a>降域</h3><p>域名为<a target="_blank" rel="noopener" href="http://b.wuxiaozhou.com/b%E7%9A%84%E7%BD%91%E9%A1%B5**%E4%BB%A5iframe%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%B5%8C%E5%9C%A8**%E5%9F%9F%E5%90%8D%E4%B8%BAhttp://a.wuxiaozhou.com/a%E7%9A%84%E7%BD%91%E9%A1%B5%E4%B8%AD%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%9D%A5%E8%87%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E3%80%82">http://b.wuxiaozhou.com/b的网页**以iframe的形式嵌在**域名为http://a.wuxiaozhou.com/a的网页中，它们来自不同的域名，正常情况下不能进行跨域访问。</a></p>
<p>但是当我们为两个页面都加上这样一句代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;wuxiaozhou.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这时候这两个页面就位于同一个域名下面了，就可以在页面a中对页面b进行操作了，两个页面可以互相访问。</p>
<p>缺点：</p>
<ul>
<li>就是两个域名要有相同对的部分才可以，比如这个例子中的就都含有wuxiaozhou.com这一部分</li>
</ul>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage(data,origin)方法接受两个参数</p>
<p> 1.<strong>data</strong>：要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化。</p>
<p>2.<strong>origin</strong>：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p><em><a target="_blank" rel="noopener" href="http://test.com/index.html">http://test.com/index.html</a></em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:200px; float:left; margin-right:200px;border:solid 1px #333;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;color&quot;</span>&gt;</span>Frame Color<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://lsLib.com/lsLib.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以在<em><a target="_blank" rel="noopener" href="http://test.com/index.html">http://test.com/index.html</a></em>通过postMessage()方法向跨域的iframe页面<em><a target="_blank" rel="noopener" href="http://lslib.com/lsLib.html">http://lsLib.com/lsLib.html</a></em>传递消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">&#x27;getcolor&#x27;</span>,<span class="string">&#x27;http://lslib.com&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收消息</p>
<p>test.com上面的页面向lslib.com发送了消息，那么在lslib.com页面上如何接收消息呢，监听window的message事件就可以</p>
<p><em><a target="_blank" rel="noopener" href="http://lslib.com/lslib.html">http://lslib.com/lslib.html</a></em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> color=container.style.backgroundColor;</span><br><span class="line">    <span class="built_in">window</span>.parent.postMessage(color,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h1 id="前端安全问题"><a href="#前端安全问题" class="headerlink" title="前端安全问题"></a>前端安全问题</h1><h2 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h2><p>通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器。</p>
<p>1、反射型</p>
<p>原理：发生请求时，XSS代码出现在请求URL中，作为参数提交给服务器，服务器解析后响应的结果中包含XSS代码，最后浏览器解析并执行。</p>
<p>实现：攻击者通过给用户发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析执行。</p>
<p>2、存储型</p>
<p>原理：攻击者输入的恶意代码”存储“在服务器，主要是将XSS代码发送到服务器，不管是数据库、内存还是文件系统，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</p>
<p>实现：一般出现在网站留言、评论等交互处。例如：提交了一条包含XSS代码的留言到数据库，当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来，浏览器把XSS代码当作正常的HTML和JS解析执行，XSS攻击就发生了。</p>
<p><strong>XSS的防御</strong></p>
<ol>
<li>浏览器禁止页面的JS访问带有HttpOnly属性的cookie</li>
<li>输入检查（XSS Filter）让一些特殊字符的攻击失效</li>
<li>输出检查，在变量输出到HTML页面时，使用编码或者转义的方式预防XSS攻击</li>
</ol>
<h2 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h2><p>利用你所在网页的登录状态，以你的名义向网站发送恶意请求。</p>
<p>CSRF能做的事情包括利用你的身份发邮件、发短信、进行交易转账等，盗取你的账号，甚至购买商品，虚拟货币转账…造成的问题包括：个人隐私泄露以及财产安全等。</p>
<p>demo：</p>
<blockquote>
<p>用户登录自己的博客网站（本地cookie已经保存了登录信息）<br>攻击者构造一个页面：<a target="_blank" rel="noopener" href="http://www.a.com/csrf.html">http://www.a.com/csrf.html</a><br>其内容为<img src="http://blog.sohu.com/manage/entry.do?m=deleted&id=156714243" /><br>使用了一个img标签，其地址指向了删除Iid为156714243的博客文章<br>然后攻击者诱使用户访问这个页面<br>用户进去看到一张无法显示的图片，这时自己的那篇博客文章已经被删除了</p>
</blockquote>
<p>关键点：</p>
<ol>
<li>用户登录受信任网站A，并且在本地生成Cookie。</li>
<li>在不退出网站A的情况下，访问危险网站B。</li>
</ol>
<p><strong>CSRF的防御</strong></p>
<ol>
<li>增加token，在请求中放入攻击者不能伪造的信息，并且该消息不总存在于cookie中。于是，开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token检验，如果请求中没有token或者token内容不正确，则拒绝请求</li>
<li>在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址，通常情况下访问一个安全受限的页面的请求都来自于同一个网站</li>
<li>网站重要操作增加验证码，防止用户在不知情的情况下构造了网络请求收到CSRF攻击</li>
</ol>
<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="关键渲染路径优化"><a href="#关键渲染路径优化" class="headerlink" title="关键渲染路径优化"></a>关键渲染路径优化</h2><p><strong>关键渲染路径</strong>是浏览器将HTML、CSS、JavaScript转换为屏幕上呈现的像素内容所经历的一系列步骤，也就是浏览器渲染流程。</p>
<p>为了尽快完成首次渲染，要最大限度减小以下三种可变因素：</p>
<ol>
<li>可能阻止网页首次渲染的资源</li>
<li>获取所有关键资源所需的往返次数或总时间</li>
<li>所有关键资源传送文件大小的总和</li>
</ol>
<p><strong>优化DOM</strong></p>
<ol>
<li>删除不必要的代码和注释包括空格，尽量做到最小化文件。</li>
<li>可以利用 GZIP 压缩文件。</li>
<li>结合 HTTP 缓存文件。</li>
</ol>
<p><strong>优化CSSOM</strong></p>
<p>DOM 和 CSSOM 通常是并行构建的，CSS 加载不会阻塞 DOM 的解析，但是Render Tree要等待DOM Tree和CSSOM Tree都构建完成，所以对于 <strong>CSSOM</strong> 缩小、压缩以及缓存同样重要。</p>
<p><strong>优化JavaScript</strong></p>
<p>当浏览器遇到 script 标记时，会<strong>阻止解析器继续操作</strong></p>
<ol>
<li>async: 当我们在 script 标记添加 async 属性以后，浏览器遇到这个 script 标记时会继续解析 DOM，同时脚本也不会被 CSSOM 阻止，即不会阻止 CRP。</li>
<li>defer: 推迟脚本的加载，脚本需要等到文档解析后（ DOMContentLoaded 事件前）执行。</li>
<li>当我们的脚本不会修改 DOM 或 CSSOM 时，推荐使用 async 。</li>
<li>预加载 —— preload &amp; prefetch 。</li>
<li>DNS 预解析 —— dns-prefetch 。</li>
</ol>
<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>通过图片懒加载可以让一些不可视的图片不去加载，避免一次性加载过多的图片导致请求阻塞（浏览器一般对同一域名下的并发请求的连接数有限制），这样就可以提高网站的加载速度，提高用户体验。</p>
<p><strong>实例</strong></p>
<p>当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    img &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      margin-bottom: 50px;</span><br><span class="line">      width: 400px;</span><br><span class="line">      height: 400px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;img src=&quot;Go.png&quot; data-src=&quot;./lifecycle.jpeg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;Go.png&quot; data-src=&quot;./lifecycle.jpeg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;Go.png&quot; data-src=&quot;./lifecycle.jpeg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;Go.png&quot; data-src=&quot;./lifecycle.jpeg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    let num = document.getElementsByTagName(&#x27;img&#x27;).length;</span><br><span class="line">    let img = document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">    let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历</span><br><span class="line"></span><br><span class="line">    lazyload(); //页面载入完毕加载可是区域内的图片</span><br><span class="line"></span><br><span class="line">    window.onscroll = lazyload;</span><br><span class="line"></span><br><span class="line">    function lazyload() &#123; //监听页面滚动事件</span><br><span class="line">      let seeHeight = document.documentElement.clientHeight; //可见区域高度</span><br><span class="line">      let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度</span><br><span class="line">      for (let i = n; i &lt; num; i++) &#123;</span><br><span class="line">        if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">          if (img[i].getAttribute(&quot;src&quot;) == &quot;Go.png&quot;) &#123;</span><br><span class="line">            img[i].src = img[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          n = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>利用JS事件冒泡机制，把原本要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。</p>
<ol>
<li>大量减少内存占用，减少事件注册。</li>
<li>新增元素实现动态绑定事件</li>
</ol>
<p>例如，有一个列表需要绑定点击事件，每一个列表项点击都需要返回不同的结果。</p>
<p>传统写法会利用for循环遍历列表，为每一个列表元素绑定点击事件，这样会性能不好</p>
<p>改用事件委托：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;color-list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>black<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>white<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> color_list = <span class="built_in">document</span>.getElementByid(<span class="string">&#x27;color-list&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  color_list.addEventListener(<span class="string">&#x27;click&#x27;</span>, showColor, <span class="literal">true</span>); <span class="comment">// 事件句柄在捕获阶段执行</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x = e.target;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (x.nodeName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      alert(x.innerHTML);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>用户在输入内容校验等操作时，如果事件处理函数的调用频率无限制，会加重浏览器负担。</p>
<p>第一次触发事件，一段时间内没有再次触发事件，事件处理函数才会再执行一次。如果设定的事件到来之前，再一次触发了事件，就会重新开始延时。</p>
<p>下面是一个防抖的小案例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;debounce&quot;</span>&gt;</span>点我防抖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取按钮并绑定事件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">&quot;debounce&quot;</span>);</span></span><br><span class="line"><span class="javascript">        myDebounce.addEventListener(<span class="string">&quot;click&quot;</span>,debounce(sayDebounce));</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//防抖功能函数，接受传参</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//创建一个标记用来存放定时器的返回值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//每次当用户点击、输入的时候，把前一个定时器消除</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">clearTimeout</span>(timeout);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//创建一个新的setTimeout，这样能保证点击按钮后的间隔内，如果用户还点击的话，就不会执行fn函数</span></span></span><br><span class="line"><span class="javascript">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//防抖事件的处理</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;防抖成功~&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>指定时间间隔内只会执行一次任务。</p>
<p>节流的应用：<br>1、懒加载监听滚动条的位置，使用节流按照一定的频率进行获取。<br>2、点击提交按钮，只允许一定时间内点击一次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;throttle&quot;</span>&gt;</span>点我防抖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取按钮并绑定事件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">&quot;throttle&quot;</span>);</span></span><br><span class="line"><span class="javascript">        myThrottle.addEventListener(<span class="string">&quot;click&quot;</span>,throttle(sayThrottle));</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//节流函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//通过闭包保存一个标记</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//在函数开头判断标志是否为true，不为true则中断函数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!canRun)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//将canRun设置为false，防止执行之前再被执行</span></span></span><br><span class="line"><span class="javascript">            canRun  = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//定时器</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//执行完事件(例如调用完接口)之后，重新将这个标志设置为true</span></span></span><br><span class="line"><span class="javascript">                canRun  = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//需要节流的事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;节流成功~&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郭威龙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">http://example.com/2021/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">GWL's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">浏览器和网络协议</a></div><div class="post_share"><div class="social-share" data-image="https://z3.ax1x.com/2021/10/27/5T4zgf.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/08/Vue/"><img class="prev-cover" src="https://z3.ax1x.com/2021/10/27/5ToA10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/07/JS%E5%9F%BA%E7%A1%802/"><img class="next-cover" src="https://z3.ax1x.com/2021/06/07/2dcBDO.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS基础2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/TimCook.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">郭威龙</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GWL0927"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GWL0927" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1062870384@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#axios"><span class="toc-number">1.</span> <span class="toc-text">axios</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">axios相关配置属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">输入URL后发生了什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A5%E6%94%B6HTTP%E5%93%8D%E5%BA%94"><span class="toc-number">3.</span> <span class="toc-text">浏览器接收HTTP响应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">网页生成过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">浏览器回流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">哪些因素会导致回流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">如何避免回流？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">管道机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88%E6%99%AE%E9%80%9A%E7%AE%A1%E9%81%93%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">无名管道（普通管道）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">有名管道（FIFO）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">OSI七层模型和TCP&#x2F;IP五层模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.</span> <span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">8.1.</span> <span class="toc-text">请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-number">8.1.1.</span> <span class="toc-text">请求行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">请求地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">协议版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">8.1.2.</span> <span class="toc-text">请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE"><span class="toc-number">8.1.3.</span> <span class="toc-text">请求数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">8.2.</span> <span class="toc-text">响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%A1%8C"><span class="toc-number">8.2.1.</span> <span class="toc-text">状态行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC-1"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">协议版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">8.2.2.</span> <span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-number">8.2.3.</span> <span class="toc-text">响应数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">8.3.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2"><span class="toc-number">8.4.</span> <span class="toc-text">HTTP&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS"><span class="toc-number">8.4.1.</span> <span class="toc-text">SSL&#x2F;TLS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">协议特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS-%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.</span> <span class="toc-text">HTTPS 协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">HTTPS的交互流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%98%AF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">为什么数据传输是用对称加密？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">11.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">12.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">HTTP和HTTPS区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">TCP和UDP区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">GET和POST区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cookie%E5%92%8CSession"><span class="toc-number">16.</span> <span class="toc-text">Cookie和Session</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-number">16.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session"><span class="toc-number">16.2.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.3.</span> <span class="toc-text">Cookie和Session的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Web-Storage%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">Web Storage和Cookie的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">18.</span> <span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">18.1.</span> <span class="toc-text">强制缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%93%E5%AD%98%E8%A7%84%E5%88%99"><span class="toc-number">18.1.1.</span> <span class="toc-text">强制缓存的缓存规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expires"><span class="toc-number">18.2.</span> <span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Control"><span class="toc-number">18.3.</span> <span class="toc-text">Cache-Control</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">19.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">19.1.</span> <span class="toc-text">跨域的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP"><span class="toc-number">19.1.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS"><span class="toc-number">19.1.2.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E5%9F%9F"><span class="toc-number">19.1.3.</span> <span class="toc-text">降域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postMessage"><span class="toc-number">19.1.4.</span> <span class="toc-text">postMessage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">20.</span> <span class="toc-text">前端安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">20.1.</span> <span class="toc-text">XSS（跨站脚本攻击）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="toc-number">20.2.</span> <span class="toc-text">CSRF（跨站请求伪造）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">21.</span> <span class="toc-text">前端性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96"><span class="toc-number">21.1.</span> <span class="toc-text">关键渲染路径优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">21.2.</span> <span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">21.3.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">21.4.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">21.5.</span> <span class="toc-text">节流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/12/%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="方法的实现">方法的实现</a><time datetime="2021-10-12T01:48:05.000Z" title="发表于 2021-10-12 09:48:05">2021-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/11/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2021-10-11T01:48:05.000Z" title="发表于 2021-10-11 09:48:05">2021-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/10/ES6/" title="ES6">ES6</a><time datetime="2021-10-10T01:48:05.000Z" title="发表于 2021-10-10 09:48:05">2021-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/10/HTMLCSS/" title="HTMLCSS">HTMLCSS</a><time datetime="2021-10-10T01:48:05.000Z" title="发表于 2021-10-10 09:48:05">2021-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/09/JS/" title="JS">JS</a><time datetime="2021-10-09T01:48:05.000Z" title="发表于 2021-10-09 09:48:05">2021-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 郭威龙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>